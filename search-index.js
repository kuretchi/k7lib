var searchIndex = JSON.parse('{\
"spella":{"doc":"My own competitive programming library for Rust.","i":[[0,"algebra","spella","Algebra.",null,null],[3,"ModInt","spella::algebra","A ring of integers modulo $n$ ($\\\\mathbb{Z}/n\\\\mathbb{Z}$).",null,null],[11,"new","","Creates a new `ModInt` with the given representative.",0,[[]]],[11,"repr","","Returns the canonical representative.",0,[[]]],[11,"recip","","Returns the multiplicative inverse if it exists.",0,[[],["option",4]]],[0,"structures","","Algebraic structures.",null,null],[3,"All","spella::algebra::structures","A monoid under conjunction `&&`.",null,null],[12,"0","","",1,null],[3,"Any","","A monoid under disjunction `||`.",null,null],[12,"0","","",2,null],[3,"First","","A left zero semigroup.",null,null],[12,"0","","",3,null],[3,"Last","","A right zero semigroup.",null,null],[12,"0","","",4,null],[3,"Max","","A monoid that returns the maximum value.",null,null],[12,"0","","",5,null],[3,"Min","","A monoid that returns the minimum value.",null,null],[12,"0","","",6,null],[3,"Product","","A monoid under semiring multiplication.",null,null],[12,"0","","",7,null],[3,"Sum","","A commutative monoid under semiring addition.",null,null],[12,"0","","",8,null],[8,"CommutativeSemigroup","","A commutative semigroup.",null,null],[8,"CommutativeSemiring","","A commutative semiring.",null,null],[8,"Group","","A group.",null,null],[10,"invert","","Returns an inverse element.",9,[[]]],[11,"inverse_op","","Returns `self.op(&rhs.invert())`.",9,[[]]],[11,"inverse_op_assign_right","","Assigns `self.inverse_op(rhs)` to `self`.",9,[[]]],[11,"inverse_op_assign_left","","Assigns `lhs.inverse_op(self)` to `self`.",9,[[]]],[8,"Monoid","","A monoid.",null,null],[10,"identity","","Returns an identity element.",10,[[]]],[8,"Ring","","A ring.",null,null],[10,"neg","","Returns an additive inverse.",11,[[]]],[8,"Semigroup","","A semigroup.",null,null],[10,"op","","Performs a binary operation.",12,[[]]],[11,"op_assign_right","","Assigns `self.op(rhs)` to `self`.",12,[[]]],[11,"op_assign_left","","Assigns `lhs.op(self)` to `self`.",12,[[]]],[8,"Semiring","","A semiring.",null,null],[10,"add","","Performs addition.",13,[[]]],[10,"mul","","Performs multiplication.",13,[[]]],[10,"zero","","Returns the additive identity.",13,[[]]],[10,"one","","Returns the multiplicative identity.",13,[[]]],[0,"byte","spella","Single-byte character/string types.",null,null],[3,"ByteChar","spella::byte","A single-byte character.",null,null],[12,"0","","",14,null],[3,"ParseByteCharError","","An error which can be returned when parsing a `ByteChar`.",null,null],[0,"cmp","spella","Extensions for ordering and comparison.",null,null],[8,"Bounded","spella::cmp","Trait for types that have min/max values.",null,null],[18,"MIN","","",15,null],[18,"MAX","","",15,null],[0,"constant","spella","Utilities related to constant values.",null,null],[8,"Constant","spella::constant","A trait for marker types that represents a constant value.",null,null],[10,"get","","Returns the constant value.",16,[[]]],[0,"disjoint_sets","spella","Disjoint-set data structures (a.k.a. union-find data…",null,null],[3,"QuickFind","spella::disjoint_sets","A disjoint-set data structure based on the weighted…",null,null],[3,"QuickUnion","","A disjoint-set data structure based on the weighted…",null,null],[11,"new","","Creates a new `QuickFind` with the given number of elements.",17,[[]]],[11,"len","","Returns the total number of elements that belong to…",17,[[]]],[11,"sets_len","","Returns the number of disjoint sets.",17,[[]]],[11,"find","","Returns the representative of the set that the given…",17,[[]]],[11,"unite","","Unites two disjoint sets that the given elements belong to…",17,[[]]],[11,"belong_to_same_set","","Returns `true` iff the given elements belong to the same…",17,[[]]],[11,"set","","Returns the slice of elements that belong to the same set…",17,[[]]],[11,"new","","Creates a new `QuickUnion` with the given number of…",18,[[]]],[11,"len","","Returns the total number of elements that belong to…",18,[[]]],[11,"sets_len","","Returns the number of disjoint sets.",18,[[]]],[11,"find","","Returns the representative of the set that the given…",18,[[]]],[11,"unite","","Unites two disjoint sets that the given elements belong to…",18,[[]]],[11,"belong_to_same_set","","Returns `true` iff the given elements belong to the same…",18,[[]]],[11,"set_len","","Returns the number of elements that belong to the same set…",18,[[]]],[0,"io","spella","Utilities related to I/O.",null,null],[3,"Scanner","spella::io","Wraps a reader and tokenizes its input.",null,null],[5,"run","","",null,[[["option",4]],["result",6]]],[11,"new","","Creates a new `Scanner`.",19,[[]]],[11,"next","","Returns a next token splitted by whitespaces.",19,[[],["result",6]]],[11,"next_line","","Returns a whole string slice before the next newline…",19,[[],["result",6]]],[11,"parse_next","","Parses a next token splitted by whitespaces, and returns it.",19,[[],[["result",4],["result",6]]]],[0,"num","spella","Utilities related to numeric types.",null,null],[5,"gcd","spella::num","Returns the greatest common divisor.",null,[[]]],[5,"lcm","","Returns the least common multiple if it exists.",null,[[],["option",4]]],[0,"primitive","","Traits for primitive numeric types.",null,null],[8,"Int","spella::num::primitive","A trait for primitive integer types.",null,null],[18,"ZERO","","The constant value `0`.",20,null],[18,"ONE","","The constant value `1`.",20,null],[10,"from_str_radix","","",20,[[],[["result",4],["parseinterror",3]]]],[10,"count_ones","","",20,[[]]],[10,"count_zeros","","",20,[[]]],[10,"leading_zeros","","",20,[[]]],[10,"trailing_zeros","","",20,[[]]],[10,"rotate_left","","",20,[[]]],[10,"rotate_right","","",20,[[]]],[10,"swap_bytes","","",20,[[]]],[10,"reverse_bits","","",20,[[]]],[10,"checked_add","","",20,[[],["option",4]]],[10,"checked_sub","","",20,[[],["option",4]]],[10,"checked_mul","","",20,[[],["option",4]]],[10,"checked_div","","",20,[[],["option",4]]],[10,"checked_div_euclid","","",20,[[],["option",4]]],[10,"checked_rem","","",20,[[],["option",4]]],[10,"checked_rem_euclid","","",20,[[],["option",4]]],[10,"checked_neg","","",20,[[],["option",4]]],[10,"checked_shl","","",20,[[],["option",4]]],[10,"checked_shr","","",20,[[],["option",4]]],[10,"checked_pow","","",20,[[],["option",4]]],[10,"saturating_add","","",20,[[]]],[10,"saturating_sub","","",20,[[]]],[10,"saturating_mul","","",20,[[]]],[10,"saturating_pow","","",20,[[]]],[10,"wrapping_add","","",20,[[]]],[10,"wrapping_sub","","",20,[[]]],[10,"wrapping_mul","","",20,[[]]],[10,"wrapping_div","","",20,[[]]],[10,"wrapping_div_euclid","","",20,[[]]],[10,"wrapping_rem","","",20,[[]]],[10,"wrapping_rem_euclid","","",20,[[]]],[10,"wrapping_neg","","",20,[[]]],[10,"wrapping_shl","","",20,[[]]],[10,"wrapping_shr","","",20,[[]]],[10,"wrapping_pow","","",20,[[]]],[10,"overflowing_add","","",20,[[]]],[10,"overflowing_sub","","",20,[[]]],[10,"overflowing_mul","","",20,[[]]],[10,"overflowing_div","","",20,[[]]],[10,"overflowing_div_euclid","","",20,[[]]],[10,"overflowing_rem","","",20,[[]]],[10,"overflowing_rem_euclid","","",20,[[]]],[10,"overflowing_neg","","",20,[[]]],[10,"overflowing_shl","","",20,[[]]],[10,"overflowing_shr","","",20,[[]]],[10,"overflowing_pow","","",20,[[]]],[10,"pow","","",20,[[]]],[10,"div_euclid","","",20,[[]]],[10,"rem_euclid","","",20,[[]]],[8,"SignedInt","","A trait for primitive signed integer types.",null,null],[10,"checked_abs","","",21,[[],["option",4]]],[10,"wrapping_abs","","",21,[[]]],[10,"overflowing_abs","","",21,[[]]],[10,"abs","","",21,[[]]],[10,"signum","","",21,[[]]],[10,"is_positive","","",21,[[]]],[10,"is_negative","","",21,[[]]],[8,"UnsignedInt","","A trait for primitive unsigned integer types.",null,null],[10,"is_power_of_two","","",22,[[]]],[10,"next_power_of_two","","",22,[[]]],[10,"checked_next_power_of_two","","",22,[[],["option",4]]],[0,"sequences","spella","Data structures representing a sequence.",null,null],[0,"cumulative_sum","spella::sequences","A cumulative sum.",null,null],[3,"CumulativeSum","spella::sequences::cumulative_sum","A cumulative sum.",null,null],[11,"new","","Creates an empty sequence.",23,[[]]],[11,"push","","Appends an element to the back of the sequence.",23,[[]]],[11,"len","","Returns the length of the sequence.",23,[[]]],[11,"prefix_sum","","Folds elements in the given prefix range with a monoid\'s…",23,[[["rangeto",3]]]],[11,"point_get","","Returns an element at the given index.",23,[[]]],[11,"range_sum","","Folds elements in the given range with a group\'s binary…",23,[[["range",3]]]],[0,"fenwick_tree","spella::sequences","A fenwick tree (a.k.a. binary indexed tree).",null,null],[3,"FenwickTree","spella::sequences::fenwick_tree","A fenwick tree (a.k.a. binary indexed tree).",null,null],[11,"new","","Creates a new `FenwickTree` of the given length, filled…",24,[[]]],[11,"len","","Returns the length of the sequence.",24,[[]]],[11,"point_append","","Append the given value to an element at the given index…",24,[[]]],[11,"prefix_sum","","Folds elements in the given prefix range with a monoid\'s…",24,[[["rangeto",3]]]],[11,"point_get","","Returns an element at the given index.",24,[[]]],[11,"point_set","","Replaces an element at the given index with the given…",24,[[]]],[11,"range_sum","","Folds elements in the given range with a group\'s binary…",24,[[["range",3]]]],[0,"segment_tree","spella::sequences","A segment tree.",null,null],[3,"SegmentTree","spella::sequences::segment_tree","A segment tree.",null,null],[3,"PointGetMut","","Structure wrapping a mutable refenrece to an element on…",null,null],[11,"new","","Creates a new `SegmentTree` of the given length, filled…",25,[[]]],[11,"len","","Returns the length of the sequence.",25,[[]]],[11,"point_get","","Returns an element at the given index.",25,[[]]],[11,"point_get_mut","","Returns a mutable reference to an element at the given…",25,[[],["pointgetmut",3]]],[11,"range_sum","","Folds elements in the given range with a monoid\'s binary…",25,[[["range",3]]]],[11,"update","","Updates the value using the given function.",26,[[]]],[0,"string","spella","Algorithms and data structures for processing strings.",null,null],[3,"RunLengthEncode","spella::string","An iterator created by [`run_length_encode`].",null,null],[5,"next_permutation","","Permutes the slice into the next greater permutation in…",null,[[]]],[5,"next_permutation_by","","Permutes the slice into the next greater permutation in…",null,[[]]],[5,"next_permutation_by_key","","Permutes the slice into the next greater permutation in…",null,[[]]],[5,"run_length_encode","","Creates a run-length encoded iterator of the given iterator.",null,[[],["runlengthencode",3]]],[14,"constant","spella","Creates a marker type that represents a constant value.",null,null],[11,"from","spella::algebra","",0,[[]]],[11,"into","","",0,[[]]],[11,"to_owned","","",0,[[]]],[11,"clone_into","","",0,[[]]],[11,"to_string","","",0,[[],["string",3]]],[11,"borrow","","",0,[[]]],[11,"borrow_mut","","",0,[[]]],[11,"try_from","","",0,[[],["result",4]]],[11,"try_into","","",0,[[],["result",4]]],[11,"type_id","","",0,[[],["typeid",3]]],[11,"from","spella::algebra::structures","",1,[[]]],[11,"into","","",1,[[]]],[11,"to_owned","","",1,[[]]],[11,"clone_into","","",1,[[]]],[11,"borrow","","",1,[[]]],[11,"borrow_mut","","",1,[[]]],[11,"try_from","","",1,[[],["result",4]]],[11,"try_into","","",1,[[],["result",4]]],[11,"type_id","","",1,[[],["typeid",3]]],[11,"from","","",2,[[]]],[11,"into","","",2,[[]]],[11,"to_owned","","",2,[[]]],[11,"clone_into","","",2,[[]]],[11,"borrow","","",2,[[]]],[11,"borrow_mut","","",2,[[]]],[11,"try_from","","",2,[[],["result",4]]],[11,"try_into","","",2,[[],["result",4]]],[11,"type_id","","",2,[[],["typeid",3]]],[11,"from","","",3,[[]]],[11,"into","","",3,[[]]],[11,"to_owned","","",3,[[]]],[11,"clone_into","","",3,[[]]],[11,"borrow","","",3,[[]]],[11,"borrow_mut","","",3,[[]]],[11,"try_from","","",3,[[],["result",4]]],[11,"try_into","","",3,[[],["result",4]]],[11,"type_id","","",3,[[],["typeid",3]]],[11,"from","","",4,[[]]],[11,"into","","",4,[[]]],[11,"to_owned","","",4,[[]]],[11,"clone_into","","",4,[[]]],[11,"borrow","","",4,[[]]],[11,"borrow_mut","","",4,[[]]],[11,"try_from","","",4,[[],["result",4]]],[11,"try_into","","",4,[[],["result",4]]],[11,"type_id","","",4,[[],["typeid",3]]],[11,"from","","",5,[[]]],[11,"into","","",5,[[]]],[11,"to_owned","","",5,[[]]],[11,"clone_into","","",5,[[]]],[11,"borrow","","",5,[[]]],[11,"borrow_mut","","",5,[[]]],[11,"try_from","","",5,[[],["result",4]]],[11,"try_into","","",5,[[],["result",4]]],[11,"type_id","","",5,[[],["typeid",3]]],[11,"from","","",6,[[]]],[11,"into","","",6,[[]]],[11,"to_owned","","",6,[[]]],[11,"clone_into","","",6,[[]]],[11,"borrow","","",6,[[]]],[11,"borrow_mut","","",6,[[]]],[11,"try_from","","",6,[[],["result",4]]],[11,"try_into","","",6,[[],["result",4]]],[11,"type_id","","",6,[[],["typeid",3]]],[11,"from","","",7,[[]]],[11,"into","","",7,[[]]],[11,"to_owned","","",7,[[]]],[11,"clone_into","","",7,[[]]],[11,"borrow","","",7,[[]]],[11,"borrow_mut","","",7,[[]]],[11,"try_from","","",7,[[],["result",4]]],[11,"try_into","","",7,[[],["result",4]]],[11,"type_id","","",7,[[],["typeid",3]]],[11,"from","","",8,[[]]],[11,"into","","",8,[[]]],[11,"to_owned","","",8,[[]]],[11,"clone_into","","",8,[[]]],[11,"borrow","","",8,[[]]],[11,"borrow_mut","","",8,[[]]],[11,"try_from","","",8,[[],["result",4]]],[11,"try_into","","",8,[[],["result",4]]],[11,"type_id","","",8,[[],["typeid",3]]],[11,"from","spella::byte","",14,[[]]],[11,"into","","",14,[[]]],[11,"to_owned","","",14,[[]]],[11,"clone_into","","",14,[[]]],[11,"to_string","","",14,[[],["string",3]]],[11,"borrow","","",14,[[]]],[11,"borrow_mut","","",14,[[]]],[11,"try_from","","",14,[[],["result",4]]],[11,"try_into","","",14,[[],["result",4]]],[11,"type_id","","",14,[[],["typeid",3]]],[11,"from","","",27,[[]]],[11,"into","","",27,[[]]],[11,"to_owned","","",27,[[]]],[11,"clone_into","","",27,[[]]],[11,"to_string","","",27,[[],["string",3]]],[11,"borrow","","",27,[[]]],[11,"borrow_mut","","",27,[[]]],[11,"try_from","","",27,[[],["result",4]]],[11,"try_into","","",27,[[],["result",4]]],[11,"type_id","","",27,[[],["typeid",3]]],[11,"from","spella::disjoint_sets","",17,[[]]],[11,"into","","",17,[[]]],[11,"to_owned","","",17,[[]]],[11,"clone_into","","",17,[[]]],[11,"borrow","","",17,[[]]],[11,"borrow_mut","","",17,[[]]],[11,"try_from","","",17,[[],["result",4]]],[11,"try_into","","",17,[[],["result",4]]],[11,"type_id","","",17,[[],["typeid",3]]],[11,"from","","",18,[[]]],[11,"into","","",18,[[]]],[11,"to_owned","","",18,[[]]],[11,"clone_into","","",18,[[]]],[11,"borrow","","",18,[[]]],[11,"borrow_mut","","",18,[[]]],[11,"try_from","","",18,[[],["result",4]]],[11,"try_into","","",18,[[],["result",4]]],[11,"type_id","","",18,[[],["typeid",3]]],[11,"from","spella::io","",19,[[]]],[11,"into","","",19,[[]]],[11,"borrow","","",19,[[]]],[11,"borrow_mut","","",19,[[]]],[11,"try_from","","",19,[[],["result",4]]],[11,"try_into","","",19,[[],["result",4]]],[11,"type_id","","",19,[[],["typeid",3]]],[11,"from","spella::sequences::cumulative_sum","",23,[[]]],[11,"into","","",23,[[]]],[11,"to_owned","","",23,[[]]],[11,"clone_into","","",23,[[]]],[11,"borrow","","",23,[[]]],[11,"borrow_mut","","",23,[[]]],[11,"try_from","","",23,[[],["result",4]]],[11,"try_into","","",23,[[],["result",4]]],[11,"type_id","","",23,[[],["typeid",3]]],[11,"from","spella::sequences::fenwick_tree","",24,[[]]],[11,"into","","",24,[[]]],[11,"to_owned","","",24,[[]]],[11,"clone_into","","",24,[[]]],[11,"borrow","","",24,[[]]],[11,"borrow_mut","","",24,[[]]],[11,"try_from","","",24,[[],["result",4]]],[11,"try_into","","",24,[[],["result",4]]],[11,"type_id","","",24,[[],["typeid",3]]],[11,"from","spella::sequences::segment_tree","",25,[[]]],[11,"into","","",25,[[]]],[11,"to_owned","","",25,[[]]],[11,"clone_into","","",25,[[]]],[11,"borrow","","",25,[[]]],[11,"borrow_mut","","",25,[[]]],[11,"try_from","","",25,[[],["result",4]]],[11,"try_into","","",25,[[],["result",4]]],[11,"type_id","","",25,[[],["typeid",3]]],[11,"from","","",26,[[]]],[11,"into","","",26,[[]]],[11,"borrow","","",26,[[]]],[11,"borrow_mut","","",26,[[]]],[11,"try_from","","",26,[[],["result",4]]],[11,"try_into","","",26,[[],["result",4]]],[11,"type_id","","",26,[[],["typeid",3]]],[11,"from","spella::string","",28,[[]]],[11,"into","","",28,[[]]],[11,"into_iter","","",28,[[]]],[11,"to_owned","","",28,[[]]],[11,"clone_into","","",28,[[]]],[11,"borrow","","",28,[[]]],[11,"borrow_mut","","",28,[[]]],[11,"try_from","","",28,[[],["result",4]]],[11,"try_into","","",28,[[],["result",4]]],[11,"type_id","","",28,[[],["typeid",3]]],[11,"invert","spella::algebra::structures","",8,[[]]],[11,"identity","","",1,[[]]],[11,"identity","","",2,[[]]],[11,"identity","","",5,[[]]],[11,"identity","","",6,[[]]],[11,"identity","","",7,[[]]],[11,"identity","","",8,[[]]],[11,"neg","spella::algebra","",0,[[]]],[11,"op","spella::algebra::structures","",1,[[]]],[11,"op","","",2,[[]]],[11,"op","","",3,[[]]],[11,"op","","",4,[[]]],[11,"op","","",5,[[]]],[11,"op","","",6,[[]]],[11,"op","","",7,[[]]],[11,"op","","",8,[[]]],[11,"add","spella::algebra","",0,[[]]],[11,"mul","","",0,[[]]],[11,"zero","","",0,[[]]],[11,"one","","",0,[[]]],[11,"drop","spella::sequences::segment_tree","",26,[[]]],[11,"from","spella::algebra","",0,[[]]],[11,"from","spella::sequences::fenwick_tree","Creates a new `FenwickTree` from a `Vec`.",24,[[["vec",3]]]],[11,"next","spella::string","",28,[[],["option",4]]],[11,"size_hint","","",28,[[]]],[11,"clone","spella::algebra","",0,[[]]],[11,"clone","spella::algebra::structures","",1,[[],["all",3]]],[11,"clone","","",2,[[],["any",3]]],[11,"clone","","",3,[[],["first",3]]],[11,"clone","","",4,[[],["last",3]]],[11,"clone","","",5,[[],["max",3]]],[11,"clone","","",6,[[],["min",3]]],[11,"clone","","",7,[[],["product",3]]],[11,"clone","","",8,[[],["sum",3]]],[11,"clone","spella::byte","",14,[[],["bytechar",3]]],[11,"clone","","",27,[[],["parsebytecharerror",3]]],[11,"clone","spella::disjoint_sets","",17,[[],["quickfind",3]]],[11,"clone","","",18,[[],["quickunion",3]]],[11,"clone","spella::sequences::cumulative_sum","",23,[[],["cumulativesum",3]]],[11,"clone","spella::sequences::fenwick_tree","",24,[[],["fenwicktree",3]]],[11,"clone","spella::sequences::segment_tree","",25,[[],["segmenttree",3]]],[11,"clone","spella::string","",28,[[],["runlengthencode",3]]],[11,"default","spella::algebra","",0,[[]]],[11,"default","spella::algebra::structures","",1,[[],["all",3]]],[11,"default","","",2,[[],["any",3]]],[11,"default","","",3,[[],["first",3]]],[11,"default","","",4,[[],["last",3]]],[11,"default","","",5,[[],["max",3]]],[11,"default","","",6,[[],["min",3]]],[11,"default","","",7,[[],["product",3]]],[11,"default","","",8,[[],["sum",3]]],[11,"default","spella::byte","",14,[[],["bytechar",3]]],[11,"cmp","spella::algebra::structures","",1,[[["all",3]],["ordering",4]]],[11,"cmp","","",2,[[["any",3]],["ordering",4]]],[11,"cmp","","",3,[[["first",3]],["ordering",4]]],[11,"cmp","","",4,[[["last",3]],["ordering",4]]],[11,"cmp","","",5,[[["max",3]],["ordering",4]]],[11,"cmp","","",6,[[["min",3]],["ordering",4]]],[11,"cmp","","",7,[[["product",3]],["ordering",4]]],[11,"cmp","","",8,[[["sum",3]],["ordering",4]]],[11,"cmp","spella::byte","",14,[[["bytechar",3]],["ordering",4]]],[11,"eq","spella::algebra","",0,[[]]],[11,"eq","spella::algebra::structures","",1,[[["all",3]]]],[11,"ne","","",1,[[["all",3]]]],[11,"eq","","",2,[[["any",3]]]],[11,"ne","","",2,[[["any",3]]]],[11,"eq","","",3,[[["first",3]]]],[11,"ne","","",3,[[["first",3]]]],[11,"eq","","",4,[[["last",3]]]],[11,"ne","","",4,[[["last",3]]]],[11,"eq","","",5,[[["max",3]]]],[11,"ne","","",5,[[["max",3]]]],[11,"eq","","",6,[[["min",3]]]],[11,"ne","","",6,[[["min",3]]]],[11,"eq","","",7,[[["product",3]]]],[11,"ne","","",7,[[["product",3]]]],[11,"eq","","",8,[[["sum",3]]]],[11,"ne","","",8,[[["sum",3]]]],[11,"eq","spella::byte","",14,[[["bytechar",3]]]],[11,"ne","","",14,[[["bytechar",3]]]],[11,"eq","","",27,[[["parsebytecharerror",3]]]],[11,"ne","","",27,[[["parsebytecharerror",3]]]],[11,"eq","spella::sequences::cumulative_sum","",23,[[["cumulativesum",3]]]],[11,"ne","","",23,[[["cumulativesum",3]]]],[11,"eq","spella::sequences::fenwick_tree","",24,[[["fenwicktree",3]]]],[11,"ne","","",24,[[["fenwicktree",3]]]],[11,"eq","spella::sequences::segment_tree","",25,[[["segmenttree",3]]]],[11,"ne","","",25,[[["segmenttree",3]]]],[11,"partial_cmp","spella::algebra::structures","",1,[[["all",3]],[["ordering",4],["option",4]]]],[11,"lt","","",1,[[["all",3]]]],[11,"le","","",1,[[["all",3]]]],[11,"gt","","",1,[[["all",3]]]],[11,"ge","","",1,[[["all",3]]]],[11,"partial_cmp","","",2,[[["any",3]],[["ordering",4],["option",4]]]],[11,"lt","","",2,[[["any",3]]]],[11,"le","","",2,[[["any",3]]]],[11,"gt","","",2,[[["any",3]]]],[11,"ge","","",2,[[["any",3]]]],[11,"partial_cmp","","",3,[[["first",3]],[["ordering",4],["option",4]]]],[11,"lt","","",3,[[["first",3]]]],[11,"le","","",3,[[["first",3]]]],[11,"gt","","",3,[[["first",3]]]],[11,"ge","","",3,[[["first",3]]]],[11,"partial_cmp","","",4,[[["last",3]],[["ordering",4],["option",4]]]],[11,"lt","","",4,[[["last",3]]]],[11,"le","","",4,[[["last",3]]]],[11,"gt","","",4,[[["last",3]]]],[11,"ge","","",4,[[["last",3]]]],[11,"partial_cmp","","",5,[[["max",3]],[["ordering",4],["option",4]]]],[11,"lt","","",5,[[["max",3]]]],[11,"le","","",5,[[["max",3]]]],[11,"gt","","",5,[[["max",3]]]],[11,"ge","","",5,[[["max",3]]]],[11,"partial_cmp","","",6,[[["min",3]],[["ordering",4],["option",4]]]],[11,"lt","","",6,[[["min",3]]]],[11,"le","","",6,[[["min",3]]]],[11,"gt","","",6,[[["min",3]]]],[11,"ge","","",6,[[["min",3]]]],[11,"partial_cmp","","",7,[[["product",3]],[["ordering",4],["option",4]]]],[11,"lt","","",7,[[["product",3]]]],[11,"le","","",7,[[["product",3]]]],[11,"gt","","",7,[[["product",3]]]],[11,"ge","","",7,[[["product",3]]]],[11,"partial_cmp","","",8,[[["sum",3]],[["ordering",4],["option",4]]]],[11,"lt","","",8,[[["sum",3]]]],[11,"le","","",8,[[["sum",3]]]],[11,"gt","","",8,[[["sum",3]]]],[11,"ge","","",8,[[["sum",3]]]],[11,"partial_cmp","spella::byte","",14,[[["bytechar",3]],[["ordering",4],["option",4]]]],[11,"lt","","",14,[[["bytechar",3]]]],[11,"le","","",14,[[["bytechar",3]]]],[11,"gt","","",14,[[["bytechar",3]]]],[11,"ge","","",14,[[["bytechar",3]]]],[11,"deref","spella::sequences::segment_tree","",26,[[]]],[11,"deref_mut","","",26,[[]]],[11,"fmt","spella::algebra","",0,[[["formatter",3]],["result",6]]],[11,"fmt","spella::algebra::structures","",1,[[["formatter",3]],["result",6]]],[11,"fmt","","",2,[[["formatter",3]],["result",6]]],[11,"fmt","","",3,[[["formatter",3]],["result",6]]],[11,"fmt","","",4,[[["formatter",3]],["result",6]]],[11,"fmt","","",5,[[["formatter",3]],["result",6]]],[11,"fmt","","",6,[[["formatter",3]],["result",6]]],[11,"fmt","","",7,[[["formatter",3]],["result",6]]],[11,"fmt","","",8,[[["formatter",3]],["result",6]]],[11,"fmt","spella::byte","",14,[[["formatter",3]],["result",6]]],[11,"fmt","","",27,[[["formatter",3]],["result",6]]],[11,"fmt","spella::disjoint_sets","",17,[[["formatter",3]],["result",6]]],[11,"fmt","","",18,[[["formatter",3]],["result",6]]],[11,"fmt","spella::io","",19,[[["formatter",3]],["result",6]]],[11,"fmt","spella::sequences::cumulative_sum","",23,[[["formatter",3]],["result",6]]],[11,"fmt","spella::sequences::fenwick_tree","",24,[[["formatter",3]],["result",6]]],[11,"fmt","spella::sequences::segment_tree","",25,[[["formatter",3]],["result",6]]],[11,"fmt","spella::string","",28,[[["formatter",3]],["result",6]]],[11,"fmt","spella::algebra","",0,[[["formatter",3]],["result",6]]],[11,"fmt","spella::byte","",14,[[["formatter",3]],["result",6]]],[11,"fmt","","",27,[[["formatter",3]],["result",6]]],[11,"div","spella::algebra","",0,[[]]],[11,"sub","","",0,[[]]],[11,"add","","",0,[[]]],[11,"mul","","",0,[[]]],[11,"neg","","",0,[[]]],[11,"add_assign","","",0,[[]]],[11,"sub_assign","","",0,[[]]],[11,"mul_assign","","",0,[[]]],[11,"div_assign","","",0,[[]]],[11,"hash","","",0,[[]]],[11,"hash","spella::algebra::structures","",1,[[]]],[11,"hash","","",2,[[]]],[11,"hash","","",3,[[]]],[11,"hash","","",4,[[]]],[11,"hash","","",5,[[]]],[11,"hash","","",6,[[]]],[11,"hash","","",7,[[]]],[11,"hash","","",8,[[]]],[11,"hash","spella::byte","",14,[[]]],[11,"hash","","",27,[[]]],[11,"hash","spella::sequences::cumulative_sum","",23,[[]]],[11,"hash","spella::sequences::fenwick_tree","",24,[[]]],[11,"hash","spella::sequences::segment_tree","",25,[[]]],[11,"from_str","spella::byte","",14,[[],[["result",4],["bytechar",3],["parsebytecharerror",3]]]],[11,"from_iter","spella::sequences::cumulative_sum","Creates a new `CumulativeSum` from an iterator.",23,[[]]],[11,"from_iter","spella::sequences::fenwick_tree","Creates a new `FenwickTree` from an iterator.",24,[[]]],[11,"from_iter","spella::sequences::segment_tree","",25,[[]]],[11,"sum","spella::algebra","",0,[[["iterator",8]]]],[11,"product","","",0,[[["iterator",8]]]],[11,"inverse_op","spella::algebra::structures","Returns `self.op(&rhs.invert())`.",9,[[]]],[11,"inverse_op_assign_right","","Assigns `self.inverse_op(rhs)` to `self`.",9,[[]]],[11,"inverse_op_assign_left","","Assigns `lhs.inverse_op(self)` to `self`.",9,[[]]],[11,"op_assign_right","","Assigns `self.op(rhs)` to `self`.",12,[[]]],[11,"op_assign_left","","Assigns `lhs.op(self)` to `self`.",12,[[]]],[18,"MIN","spella::cmp","",15,null],[18,"MAX","","",15,null],[18,"ZERO","spella::num::primitive","The constant value `0`.",20,null],[18,"ONE","","The constant value `1`.",20,null]],"p":[[3,"ModInt"],[3,"All"],[3,"Any"],[3,"First"],[3,"Last"],[3,"Max"],[3,"Min"],[3,"Product"],[3,"Sum"],[8,"Group"],[8,"Monoid"],[8,"Ring"],[8,"Semigroup"],[8,"Semiring"],[3,"ByteChar"],[8,"Bounded"],[8,"Constant"],[3,"QuickFind"],[3,"QuickUnion"],[3,"Scanner"],[8,"Int"],[8,"SignedInt"],[8,"UnsignedInt"],[3,"CumulativeSum"],[3,"FenwickTree"],[3,"SegmentTree"],[3,"PointGetMut"],[3,"ParseByteCharError"],[3,"RunLengthEncode"]]}\
}');
addSearchOptions(searchIndex);initSearch(searchIndex);